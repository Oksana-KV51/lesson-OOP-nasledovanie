#Задание: Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
#Цель: Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости
# (Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования. Принцип гласит, что
# программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.

#Задача: Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами. Программа должна
# быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия, не изменяя существующий код бойцов или механизм боя.
#Исходные данные:
#- Есть класс `Fighter`, представляющий бойца.
#- Есть класс `Monster`, представляющий монстра.
#- Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.
#Шаг 1:Создайте абстрактный класс для оружия - Создайте абстрактный класс `Weapon`, который будет содержать абстрактный метод `attack()`.
#Шаг 2: Реализуйте конкретные типы оружия - Создайте несколько классов, унаследованных от `Weapon`, например, `Sword` и `Bow`.
# Каждый из этих классов реализует метод `attack()` своим уникальным способом.
#Шаг 3: Модифицируйте класс `Fighter`
# - Добавьте в класс `Fighter` поле, которое будет хранить объект класса `Weapon`.
#- Добавьте метод `changeWeapon()`, который позволяет изменить оружие бойца.
#Шаг 4: Реализация боя - Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.@

from  abc import ABC, abstractmethod
class Fighter:
    def __init__(self, weapon=None):
        self.weapon = weapon
    def changeWeapon(self, weapon):
        self.weapon = weapon
        print(f'боец выбирает {self.weapon.name}!')
    def fight(self):
        if self.weapon:
            return self.weapon.attack()
        else:
            return "Боец безоружен."

class Monster:  # монстр
    def __init__(self):
        pass
    def attack(self):  # функция атаки монстра
        print('Монстр атакует!')

class Weapons(ABC):
    @abstractmethod
    def attack(self):
        pass

class Sword(Weapons):#меч
    def __init__(self):
        self.name = "меч"  # Добавляем атрибут name
    def attack(self):
        return 'боец наносит удар мечом\n монстр побежден!'

class Bow(Weapons):#лук
    def __init__(self):
        self.name = "лук"  # Добавляем атрибут name
    def attack(self):
        return 'боец стреляет из лука\n монстр побежден!'

# Создание экземпляров и тест боя
sword = Sword()
bow = Bow()
fighter = Fighter(sword)
monster = Monster()

fighter.changeWeapon(sword)  # Меняем оружие на меч
monster.attack()
print(fighter.weapon.attack())
fighter.changeWeapon(bow)  # Меняем оружие на лук
monster.attack()
print(fighter.weapon.attack())
